# Упражнение 6

## S-изрази и атоми

S-израз наричаме:
- атоми (булеви, числа, знаци, символи, низове, функции)
- наредени двойки (S1 . S2), където S1 и S2 са S-изрази

```scheme
;; нещо, което нито е празен списък, нито е наредена двойка
(define (atom? x)
  (and (not (null? x)) (not (pair? x))))
```

## Дълбоки списъци

```scheme
;; Обхождаме дълбоки списъци хоризонтално и вертикално

;; Хоризонтално дъно: достигане до празен списък '()
;; Хоризонтална стъпка: обхождане на опашката (cdr l)

;; Вертикално дъно: достигане до друг атом
;; Вертикална стъпка: обхождане на главата (car l)
(define deep-list '((1 (2)) (((3) 4) (5 (6)) () (7)) 8))
;; '

(define (count-atoms lst)
  (cond
    ((null? lst) 0)
    ((atom? lst) 1)
    (else (+ (count-atoms (car lst)) (count-atoms (cdr lst))))))

> (count-atoms deep-list) ;; => 8
```

## Функции с произволен брой аргументи

```scheme
;; функции, които приемат произволен брой аргументи
> (+ 1 2 3)   ;; => 6
> (- 1 2 3)   ;; => -4

> (max 1 2 3) ;; => 3
> (min 1 2 3) ;; => 1

;; функцията трябва да е над толкова аргумента, колкото са подадените списъци
;; ако повече от един списък е подаден, трябва всичките да са с еднаква дължина
;; (map function list1 list2 ...)
> (map + '(1 2 3) '(4 5 6))    ;; => '(5 7 9)
> (map list '(1 2 3) '(4 5 6)) ;; => '((1 4) (2 5) (3 6))

;; my-max приема задължително поне един аргумент
;; ако my-max бъде извикана с повече от един аргумент
;; всички, освен първия, ще бъдат "пакетирани" в списъка "rest"
;; (my-max 1)       => first = 1, rest = '()
;; (my-max 1 2 3 4) => first = 1, rest = '(2 3 4)
(define (my-max first . rest)
  (foldr
    (lambda (element result)
      (if (> element result)
        element
        result))
    first
    rest))

;; plus може да работи и без аргументи
;; не изисква задължително да и бъде подаден поне един аргумент (няма нищо преди .)
;; ако не и бъдат подадени аргументи - връща нулевата стойност за операцията +
(define (plus . lst)
  (foldr + 0 lst))

> (plus)       ;; => 0
> (plus 1 2 3) ;; => 6
```

## apply

```scheme
;; функцията apply приема 2 аргумента -
;; функция и списък от аргументи, над които да бъде приложена
;; (apply function argument-list)

;; използваме apply когато искаме да приложим функция
;; върху произволен брой аргументи

;; еквивалетно на (+ 1 2 3)
> (apply + '(1 2 3)) ;; => 6

;; еквивалетно на (append '(1 2) '(3 4))
> (apply append '((1 2) (3 4))) ;; => '(1 2 3 4)
```

## Задачи с дълбоки списъци

1. Дефинирайте функция `(member-deep? element lst)`, която работи като `member?`, но търси елемента и във вложените списъци, ако има такива

    ```scheme
    > (member-deep? 5 '((1 2) () ((#t #f) #t) ("test" (5) 6)))
    ;; => #t
    > (member-deep? 3 '((1 2) () ((#t #f) #t) ("test" (5) 6)))
    ;; => #f
    ```

2. Дефинирайте функция `(my-flatten lst)`, която разкрива всички вложени списъци в `lst`

    ```scheme
    > (my-flatten '((1 2) () ((#t #f) "test")))
    ;; => '(1 2 #t #f "test")
    ```

3. Дефинирайте функция `(deep-reverse lst)`, която обръща реда на елементите в списъка `lst`

    ```scheme
    > (deep-reverse '((1 (2)) (((3) 4) (5 (6)) () (7)) 8))
    ;; => '(8 ((7) () ((6) 5) (4 (3))) ((2) 1))
    ```

## [Подготовка за контролно](../exams/01-exam/README.md)

4. Дефинирайте функция `(chunk lst n)`, която разбива списъка `lst` на подсписъци с дължина `n`.  
Бележка: Последният подсписък може да е с дължина по-малка от `n`, ако дължината на `lst` не е кратна на `n`.

    ```scheme
    > (chunk '(1 1 1 2 2 2 3 3) 3)
    ;; => '((1 1 1) (2 2 2) (3 3))
    ```

5. Дефинирайте функция `(sublists lst)`, която намира всички подсписъци на `lst`

    ```scheme
    > (sublists '(1 2 3))
    ;; => '(() (1) (2) (3) (1 2) (2 3) (1 2 3)) в произволен ред
    ```

6. Дефинирайте функция `(subsets lst)`, която намира всички подмножества на `lst`

    ```scheme
    > (subsets '(1 2 3))
    ;; => '(() (1) (2) (3) (1 2) (1 3) (2 3) (1 2 3)) в произволен ред
    ```

## Задачи с произволен брой аргументи

Упътване: Използвайте `apply`

7. Дефинирайте функция `(compose* . fns)`, която приема произволен брой функции като аргументи и връща тяхната композиция

8. Дефинирайте функция `(map* func . lst)`, която работи като `map` над произволен брой списъци

9. Дефинирайте функция `(zipWith* func . lst)`, която работи аналогично на `zip` ([упражение 5](../05/README.md)), но над произволен брой списъци като аргументи и приема функция, с която да комбинира елементите

    ```scheme
    > (zipWith* + '(1 2 3)) ;; => '(1 2 3)
    > (zipWith* list '(1 2 3) '(a b) '(7 8 9 10)) ;; => '((1 a 7) (2 b 8))
    ```