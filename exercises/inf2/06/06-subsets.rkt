#lang racket

;; (add-to-front 1 '(())) => '((1))
;; (add-to-front 1 '((2) (3) (2 3))) => '((1 2) (1 3) (1 2 3))
(define (add-to-front element ll)
  (map (lambda (set) (cons element set)) ll))

;; идеята тук е, че всеки елемент в списъка може или:
;; - да се съдържа в подмножеството (cons)
;; - да не се съдържа в подмножеството (пропускаме го)

;; пример: за да намерим подмножествата на множеството {1 2},
;; първо намираме подмножествата на {2} и към всяко от тях
;; или добавяме 1 (cons), или не го добавяме (пропускаме го)
(define (subsets lst)
  (if (null? lst)
    '(())
    (append
      (add-to-front (car lst) (subsets (cdr lst)))
      (subsets (cdr lst)))))

;; (subsets 1 2 3)
;; подмножества с дължина 0: {}
;; подмножества с дължина 1: {1} = (add-to-front 1 '()), {2} = (add-to-front 2 '()), {3} = (add-to-front 3 '())
;; подмножества с дължина 2: {1 2} = (add-to-front 1 '(2)), {2 3} =  = (add-to-front 2 '(3))
;; подмножества с дължина 3: {1 2 3} = (add-to-front 1 '(2 3))