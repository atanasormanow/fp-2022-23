# Упражнение 12

## [Частично прилагане на функции](http://learnyouahaskell.com/higher-order-functions#curried-functions)

Всяка функция в Haskell всъщност приема само един аргумент.  
Всички функции, които приемат >1 аргумент, са curried функции.

```haskell
-- max е функция, която приема един аргумент - 4,
-- и връща друга функция, която приема един аргумент,
-- и го връща него или 4, в зависимост от кой е по-голям
>  max 4 5  
-- е еквивалетно на
> (max 4) 5
```

Казваме, че частично прилагаме функция, когато и подадем по-малко аргументи, отколкото приема
```haskell
multThree x y z = x * y * z  

-- частично прилагане на функцията multThree
-- multTwoWithNine e функция, която приема 2 аргумента и ги умножава с 9
multTwoWithNine = multThree 9 

> multTwoWithNine 2 3  -- => 54
```

```haskell
-- когато аргументът ни е вдясно и от двете страни на равното, можем да го пропуснем

-- sum' е функция, която приема един аргумент - списък, и го обхожда/свива
sum' xs = foldl (+) 0 xs  
-- е еквивалентно на
sum' = foldl (+) 0

plus a b = a + b -- или (+) a b
-- е еквивалентно на
plus = (+)
```

## Ляво и дясно отсичане на операции

Отсичане на операции (двуаргументни функции) наричане преобразуването им към едноаргументни функции.

```haskell
-- (<операция> <израз>) — дясно отсичане
> (^2) 3 -- => 9

-- (<израз> <операция>) — ляво отсичане
> (2^) 3 -- => 8
```

## Прилагане на функции с $

Докато прилагането на функции със space има много висок приоритет и е лявоасоциативна, прилагането на функции с \$ има много нисък приоритет и е дясноасоциативна.  

Най-често използваме \$, за да намалим броя скоби (заменяме отварящите скоби с $).

```haskell
> sum (filter (> 10) (map (*2) [2..10]))
-- е еквивалентно на
> sum $ filter (> 10) $ map (*2) [2..10]

-- можем да третираме $ като останалите ни познати функции
> map ($ 3) [(4+), (10*), (^2), sqrt]
-- => [7.0,30.0,9.0,1.7320508075688772]
```

## Композиция на функции с .

![Function Composition](./function-composition.png)

```haskell
-- negate . (* 3) е функция - композиция на две други функции
-- negate . (* 3) първо умножава аргумента си по 3, след което слага минус пред получения резултат
> (negate . (* 3)) 5 -- => -15

> map (\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]
-- e еквивалетно на
> map (negate . abs) [5,-3,-6,7,-3,2,-19,24] 

-- пример, в който частично прилагаме функциите replicate и max, 
-- за да приемат само един аргумент и да можем да ги композираме
> (sum . replicate 5 . max 6.7) 8.9
```

## Безточково програмиране

Безточковото програмиране е удобно за кратки функции, но може да направи кода по-малко четлив ако се използва за по-сложни функции.

```haskell
fn x = ceiling (negate (tan (cos (max 50 x))))
-- е еквивалетно на
fn = ceiling . negate . tan . cos . max 50

oddSquareSum = sum (takeWhile (<10000) (filter odd (map (^2) [1..])))     
-- е еквивалетно на
oddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]  
```
---

## Задачи

```haskell
matrix =
  [[1, 2],
   [3, 4],
   [5, 6]]
```

1. Дефинирайте функция `sum`, която намира сумата на всички елементи в дадена матрица

    ```haskell
    > sum matrix -- => 21
    ```

2. Дефинирайте функция `minimum`, която намира най-малкия елемент в дадената матрица

    ```haskell
    > minimum matrix -- => 1
    ```

3. Дефинирайте функция `column`, която по дадена матрица и индекс, връща колоната на този индекс

    ```haskell
    > column matrix 1 -- => [2,4,6]
    ```

4. Дефинирайте функция `matrixRef`, която по дадена матрица и индекси, връща елемента на съответната позиция

    ```haskell
    > matrixRef matrix 2 1 -- => 6
    ```

5. Дефинирайте функция `diagonal`, по дадена матрица връща главния и диагонал

    ```haskell
    > diagonal matrix -- => [1, 4]
    ```

6. Дефинирайте функция `allColumns`, която приема предикат и матрица и проверява дали за всяка колона в матрицата е изпълнен предикатът

    ```haskell
    > allColumns (\column -> 2 `elem` column) matrix -- => #f
    ```