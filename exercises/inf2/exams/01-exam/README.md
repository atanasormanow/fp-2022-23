# Подготовка за Контролно 1

### [Първо контролно (2021/22 г.)](https://learn.fmi.uni-sofia.bg/mod/page/view.php?id=259431)

### Първо контролно (2019/20 г.)

1.
    1. Да се реализира функция `product-digits`, която намира произведението от цифрите на дадено естествено число.

    2. Нека с ${n}$ означим разликата на $n$ и произведението на цифрите на $n$. Да се реализира функция `largest-diff`, която намира най-голямата разлика ${m} – {n}$ за $m, n ∈ [a, b]$, където $a$ и $b$ са параметри на функцията.

        ```scheme
        > (largest-diff 28 35) ;; => 19
        ```
2. "Метрика" наричаме функция, която приема като параметър списък от числа и връща число като резултат. Да се напише функция `max-metric`, която приема като параметри списък от метрики `ml` и списък от списъци от числа `ll` и връща метрика `m` от `ml`, за която сумата от стойностите, които `m` връща над елементите на `ll`, е максимална в сравнение с останалите метрики от `ml`.

    ```scheme
    (define (prod l) (apply * l))
    (define (sum l) (apply + l))

    > (max-metric (list sum prod) '((0 1 2) (3 4 5) (1337 0))) ;; => <sum>
    > (max-metric (list car sum) '((1000 -1000) (29 1) (42))) ;; => <car>
    ```
3. "Ниво на влагане" на атом в дълбок списък наричаме броя пъти, който трябва да се приложи операцията `car` за достигане до атома. Да се реализира функция `deep-repeat`, която в подаден дълбок списък заменя всеки атом на ниво на влагане `n` с `n` негови повторения.

    ```scheme
    > (deep-repeat '(1 (2 3) 4 (5 (6))))
    ;; => '(1 (2 2 3 3) 4 (5 5 (6 6 6)))
    ```

### Първо контролно (2018/19 г.)

1. Да се напише функция `middle-digit`, която намира средната цифра от записа на подадено естествено число `n`.  
Ако `n` е с четен брой цифри, функцията връща -1.

    ```scheme
    > (middle-digit 452)  ;; => 5
    > (middle-digit 4712) ;; => -1
    ```

2. Нека е даден списък `l` от числа и двуместна операция над числа $⊕$.  
Функцията $f$ наричаме "ендоморфизъм над `l`", ако $f$ трансформира `l` в себе си, запазвайки операцията $⊕$, т.е. $∀x∈l f(x)∈l$ и $∀x,y∈l f(x) ⊕ f(y) = f(x ⊕ y)$.  
Да се реализира функция `is-em?`, която проверява дали $f$ е ендоморфизъм.

    ```scheme
    > (is-em? '(0 1 4 6) + (lambda (x) (remainder x 3))) ;; => #t
    ```

3. Да се напише функция `(meetTwice? f g a b)`, която проверява дали в целочисления интервал $[a, b]$ съществуват две различни цели числа $x$ и $y$ такива, че $f(x) = g(x)$ и $f(y) = g(y)$.

    ```scheme
    > (meetTwice? (lambda(x)x) (lambda(x) (- x)) -3 1) ;; => #f
    > (meetTwice? (lambda(x)x) sqrt 0 5) ;; => #t
    ```

4. Казваме, че списъкът `x` = `(x1 x2 … x2n)` от цели числа се получава от прочитането `(look-and-say)`на списъка `y`, ако `y` се състои от последователно срещане на `x1` пъти `x2`, последвано от `x3` пъти `x4`, и така нататък до `x2n-1` пъти `x2n`. Да се дефинира функция `next-look-and-say`, която по даден списък `y` намира списъка `x`, получен от прочитането `y`.

    ```scheme
    > (next-look-and-say '(1 1 2 3 3));; => '(2 1 1 2 2 3)
    ```

### Първо контролно (2015/16 г.)

1. Да се напише функция `(longest-descending­ l)`, която намира низходящо сортиран подсписък на списъка от числа `l` с максимална дължина.  
Ако съществуват няколко такива подсписъка, функцията да върне първия отляво надясно.  
Упътване: Реализирайте помощна функция, която намира най-дългия низходящо сортиран префикс на даден списък.

    ```scheme
    > (longest-descending­ '(5 3 8 6 4 2 6 7 1)) ;; => '(8 6 4 2)
    > (longest-descending­ '(1 2 3 4 5 6)) ;; => '(1)
    ```

2. Да се напише функция `(max-unique ll)`, която по списък от списъци от цели числа намира най-голямото от тези от тях, които са уникални в рамките на списъка, в който се срещат.  
Ако в никой списък няма уникални числа, функцията да връща `#f`.

    ```scheme
    > (max-unique '((1 2 3 2) (5 5) (0))) ;; => 3
    > (max-unique '((1 2 1 2) (5 5) ()))  ;; => #f
    ```