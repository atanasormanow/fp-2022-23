# Упражнение 10

## Кортежи

Наредени n-торки с данни от произволен тип.

Типът на кортеж се определя от това, колко елемента комбинира + от какъв тип са елементите му.

Няма кортеж от един елемент.

```haskell
-- празен кортеж от тип ()
> ()

-- кортеж от 2 елемента от тип Int
> (1, 2) -- (Int, Int)

-- кортеж от 3 елемента от тип Int
> (1, 2, 3) -- (Int, Int, Int)

-- кортеж от 2 елемента с различен тип
> ("One", 2) -- (String, Int)

-- fst е функция, която приема наредена двойка, и връща първия и елемент
> fst (1, 2) -- => 1

-- snd е функция, която приема наредена двойка, и връща втория и елемент
> snd (1, 2) -- => 2

-- fst и snd са дефинирани само за наредени двойки
-- за кортежи с повече елементи, трябва сами да си 
-- дефинираме съответните функции
> fst (1, 2, 3) -- => грешка

-- кортежите могат да бъдат сравнявани един с друг,
-- ако са от един и същи тип и техните елементи могат 
-- да бъдат сравнявани
> (2, 3) > (2, 1) -- True
> (2, 3) > (2, 2) -- True
> (2, 3) > (2, 4) -- False 
```

## Списъци

Хомогенна структура от данни (всички елементи в списъка трябва да са от един и същи тип).

Рекурсивна дефиниция:

  - Празният списък `[]` е списък
  - `(h : t)` е е списък ако `t` е списък
    - `h` — глава на списъка (head)
    - `t` — опашка на списъка (tail)

```haskell
-- празният списък
> []

-- списък от Int
> [1, 2, 3, 4] -- [Int]

-- списъците могат да съдържат други списъци
-- вложените списъци могат да са с различна дължина,
-- но не и от различен тип
-- списък от списъци от Int
> [[1], [2, 3], []] -- [[Int]]

-- елементите на списъка трябва да са от един и същи тип 
> [1, 2, "three"] -- => грешка
```

```haskell
-- null проверява дали подаденият списък е празен
> null []     -- => True
> null [1, 2] -- => False

-- добавяне на елемент към началото на списък
-- еквивалентно на cons в scheme
> 1 : []   -- => [1]
> 5 : [1]  -- => [5, 1]
-- [1, 2, 3] e просто синтактична захар за 1 : 2 : 3 : []

-- конкатениране на два списъка
-- еквивалентно на append в scheme
> [1, 2] ++ [3, 4] -- => [1, 2, 3, 4]

-- head взема първия елемент на списъка (главата)
-- еквивалентно на car в scheme
> head [3, 2, 1] -- => 3
-- tail взема списъка без първия му елемент (опашката)
-- еквивалентно на cdr в scheme
> tail [3, 2, 1] -- => [2, 1]
> last [3, 2, 1] -- => 1
> init [3, 2, 1] -- => [3, 2]
```

![List Monster](./listmonster.png)

## Вградени функции за работа със списъци

```haskell
-- вземане на елемент по индекс
> [1, 2, 3] !! 1 -- => 2

> length   [1, 2, 3] -- => 3
> reverse  [1, 2, 3] -- => [3, 2, 1]

> take 2   [1, 2, 3] -- => [1, 2]
> take 5   [1, 2, 3] -- => [1, 2, 3]
> take 0   [1, 2, 3] -- => []

> drop 2   [1, 2, 3] -- => [3]
> drop 0   [1, 2, 3] -- => [1, 2, 3]
> drop 5   [1, 2, 3] -- => []

> minimum  [1, 2, 3] -- => 1
> maximum  [1, 2, 3] -- => 3
> sum      [1, 2, 3] -- => 6
> product  [1, 2, 3] -- => 6

> 2 `elem` [1, 2, 3] -- => True
> 4 `elem` [1, 2, 3] -- => False

> zip [1, 2, 3] [4, 5, 6] -- => [(1, 4), (2, 5), (3, 6)]

-- списъците могат да бъдат сравнявани един с друг,
-- ако техните елементи могат да бъдат сравнявани
-- <, <=, > и >= правят лексигокрафско сравнение
> [3, 2, 1] > [2, 1, 0] -- => True  
> [3, 2, 1] > [2, 10, 100] -- => True
> [3, 4, 2] > [3, 4] -- => True
> [3, 4, 2] > [2, 4] -- => True
> [3, 4, 2] == [3,4,2] -- => True

-- низовете са всъщност списъци от символи
-- type String = [Char]
-- можем да работим с низове, както със списъци
> "hello" ++ " " ++ "world"  -- => "hello world"
> ['h', 'e'] ++ ['l', 'l', 'o'] -- => "hello"
> 'a':" cute llama" -- => "a cute llama"
>  "a cute llama"!! 6 -- => 'e'
```

## Генератори на списъци

### Range
```haskell
-- чрез range можем да генерираме списъци,
-- които представяват аритметична прогресия
-- (има някаква дефинирана последователност над елементите)
> [1..5] -- => [1, 2, 3, 4, 5]
> ['a'..'e'] -- => "abcde"

-- можем да зададем стъпка (в този случай +2)
> [2,4..10] -- => [2, 4, 6, 8, 10]  
-- стъпка -1
> [5,4..1] -- => [5,4,3,2,1]

-- препоръчително е да използваме само целочислени числа в range
> [0.1, 0.3 .. 1] -- => [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]  
```

### List Comprehension

![Set Notion](./set-notion.png)

```haskell
-- [1..5] ни е "входното множество",
-- x * 2 е трансформацията над резултата
> [x * 2 | x <- [1..5]] -- => [2, 4, 6, 8, 10]

-- можем да зададем предикат, с който да филтрираме входните данни
> [x * 2 | x <- [1..5], x * 2 >= 5] -- => [6, 8, 10]

-- можем да зададем няколко предиката, всички трябва да са изпълнени
> [ x | x <- [10..15], x /= 13, x /= 14] -- => [10,11,12,15]

-- можем да вземаме данни от няколко списъка
-- така получаваме всички комбинации от елементи на двата списъка 
> [(x, y)| x <- [2, 5], y <- [8, 10]] -- => [(2,8),(2,10),(5,8),(5,10)]   
```

## Линейно обхождане на списъци

```haskell
-- пример - функция, която намира сумата на
-- елементите на даден списък с числа
sum lst =
  if (null lst)
    then 0
    else (head lst) + sum (tail lst)
```

Нищо ново тук! Oтново имаме:

- дъно - празен ли е списъкът
- рекурсивно извикване с "опашката" на списъка (списъка без първия си елемент)

## Pattern Matching (Образци)

```haskell
-- докато с guards проверявахме дали променливата ни изпълнява някакво условие,
-- с pattern matching проверяваме дали променливата ни съвпада с даден образец (и я деконструираме) 

-- когато дефинираме функции, можем да дефинираме отделно тяло за различните образци 

factorial 0 = 1                     -- pattern matching по литерал 0
factorial n = n * factorial (n - 1) -- всички случаи, в които променливата е различна от 0

-- образците се обхождат отгоре-надолу и се използва тялото на първия образец, който съвпадне с променливата,
-- затова изреждаме най-специфичните образци първо

-- pattern matching на наредена двойка
-- вместо това
-- addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
-- addVectors a b = (fst a + fst b, snd a + snd b)  

-- можем да напишем това
-- addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)  

-- функция, която взема първия елемент на наредена тройка
-- понеже игнорираме останалите елементи, дори не им задаваме име
first :: (a, b, c) -> a  
first (x, _, _) = x

-- pattern matching на списък
sum [] = 0  
sum (x:xs) = x + sum' xs  

-- maximum' :: (Ord a) => [a] -> a  
maximum' [] = error "maximum of empty list"  
maximum' [x] = x  
maximum' (x:xs)   
    | x > maxTail = x  
    | otherwise = maxTail  
    where maxTail = maximum' xs

-- можем да използваме именувани образци <име>@<образец>
-- когато освен деструктурираните стойности, искаме да имаме
-- достъп и до първоначалната стойност
--capital :: String -> String  
capital "" = "Empty string, whoops!"  
capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]  
```

---

## Задачи

Бележка: Слагаме ' след имената на някои от функциите по-долу, защото ги има вградени в езика.  
Алтернативно, бихме могли да добавим следния ред в началото на файла си, за да скрием дефинициите на функциите, които бихме искали да предефинираме.

```haskell
import Prelude hiding (length, product, <име-на-функция>)
```

1.  Дефинирайте функция `length' lst`, която намира дължината на списък

2. Дефинирайте функция `product' lst`, която намира произведението на елементите на подадния списък

    ```haskell
    > product' [1, 2, 3, 4, 5] -- => 120
    ```

3. Дефинирайте функция `maximum' lst`, която намира най-големия елемент в подадния списък

4. Дефинирайте функция `elem' x lst`, която проверява дали елемент се съдържа в подадния списък

    ```haskell
    > elem' 3 [1, 2, 3, 4, 5] -- => True
    > elem' 6 [1, 2, 3, 4, 5] -- => False
    ```

5. Дефинирайте функция `replicate' n element` n element, която конструира списък от `n` повторения на даден елемент

    ```haskell
    > replicate' 5 10 -- => [10, 10, 10, 10, 10]
    ```

6. Използвайте list comprehension, за да дефинирате `sumDivisors number`, която намира сумата от делителите на дадено число

    ```haskell
    > sumDivisors -- => 16
    ```

7. Използвайте list comprehension, за да дефинирате `prime`, която проверява дали дадено число е просто

8. Използвайте list comprehension, за да дефинирате  `decartes lst1 lst2`, която намира декартово произведение на два списъка

    ```haskell
    > decartes [1, 2, 3] [4, 5]
    -- => [(1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)]
    ```

9. Дефинирайте функция `histogram lst`, която за всяка уникална стойност от даден списък връща списък от наредени двойки от вида (<стойност>, <общ брой срещания>)

    ```haskell
    > histogram [1,1,2,3,3,3,4,2,2,2,1,1] 
    -- => [(1,4),(2,4),(3,3),(4,1)]
    ```

10. Дефинирайте функция `distance point1 point2`, която намира разстоянието между две точки в равнината

    ```haskell
    > distance (0, 0) (1, 1)  -- =>  1.4142135623730951
    > distance (-2, 3) (1, 7) -- => 5
    ```

11. Дефинирайте функция `maxDistance lst`, която получава списък от точки (наредени двойки (x, y)) и връща дължината на най-дългата отсечка между някои две от тях

    ```haskell
    > maxDistance [(0, 0), (1, 1), (1, 3), (2, 5)]
    -- => 5.385164807134504
    ```

12. Дефинирайте функция `rotate lst i`, която премества всеки елемент от списъка `xs` с `i` позиции наляво

    ```haskell
    > rotate "abcdefgh" 3    -- => "defghabc"
    > rotate "abcdefgh" (-2) -- => "ghabcdef"
    ```