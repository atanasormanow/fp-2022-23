# Упражнение 10

## Кортежи

Наредени n-торки с данни от произволен тип.

Типът на кортеж се определя от това, колко елемента комбинира + от какъв тип са елементите му.

Няма кортеж от един елемент.

```haskell
-- празен кортеж от тип ()
> ()

-- кортеж от 2 елемента от тип Int
> (1, 2) -- (Int, Int)

-- кортеж от 3 елемента от тип Int
> (1, 2, 3) -- (Int, Int, Int)

-- кортеж от 2 елемента с различен тип
> ("One", 2) -- (String, Int)

-- fst е функция, която приема наредена двойка, и връща първия и елемент
> fst (1, 2) -- => 1

-- fst е функция, която приема наредена двойка, и връща втория и елемент
> snd (1, 2) -- => 2

-- fst и snd са дефинирани само за наредени двойки
-- за кортежи с повече елементи, трябва сами да си 
-- дефинираме съответните функции
> fst (1, 2, 3) -- => грешка

-- кортежите могат да бъдат сравнявани един с друг,
-- ако са от един и същи тип и техните елементи могат 
-- да бъдат сравнявани
> (2, 3) > (2, 1) -- True
> (2, 3) > (2, 2) -- True
> (2, 3) > (2, 4) -- False 
```

## Списъци

Хомогенна структура от данни (всички елементи в списъка трябва да са от един и същи тип).

Рекурсивна дефиниция:

  - Празният списък `[]` е списък
  - `(h : t)` е е списък ако `t` е списък
    - `h` — глава на списъка (head)
    - `t` — опашка на списъка (tail)

```haskell
-- празният списък
> []

-- списък от Int
> [1, 2, 3, 4] -- [Int]

-- списъците могат да съдържат други списъци
-- вложените списъци могат да са с различна дължина,
-- но не и от различен тип
-- списък от списъци от Int
> [[1], [2, 3], []] -- [[Int]]

-- елементите на списъка трябва да са от един и същи тип 
> [1, 2, "three"] -- => грешка
```

```haskell
-- null проверява дали подаденият списък е празен
> null []     -- => True
> null [1, 2] -- => False

-- добавяне на елемент към началото на списък
-- еквивалентно на cons в scheme
> 1 : []   -- => [1]
> 5 : [1]  -- => [5, 1]
-- [1, 2, 3] e просто синтактична захар за 1 : 2 : 3 : []

-- конкатениране на два списъка
-- еквивалетно на append в scheme
> [1, 2] ++ [3, 4] -- => [1, 2, 3, 4]

-- head взема първия елемент на списъка (главата)
-- еквивалентно на car в scheme
> head [3, 2, 1] -- => 3
-- tail взема списъка без първия му елемент (опашката)
-- еквивалентно на cdr в scheme
> tail [3, 2, 1] -- => [2, 1]
> last [3, 2, 1] -- => 1
> init [3, 2, 1] -- => [3, 2]
```

![List Monster](./listmonster.png)

## Вградени функции за работа със списъци

```haskell
-- вземане на елемент по индекс
> [1, 2, 3] !! 1 -- => 2

> length   [1, 2, 3] -- => 3
> reverse  [1, 2, 3] -- => [3, 2, 1]

> take 2   [1, 2, 3] -- => [1, 2]
> take 5   [1, 2, 3] -- => [1, 2, 3]
> take 0   [1, 2, 3] -- => []

> drop 2   [1, 2, 3] -- => [3]
> drop 0   [1, 2, 3] -- => [1, 2, 3]
> drop 5   [1, 2, 3] -- => []

> minimum  [1, 2, 3] -- => 1
> maximum  [1, 2, 3] -- => 3
> sum      [1, 2, 3] -- => 6
> product  [1, 2, 3] -- => 6

> 2 `elem` [1, 2, 3] -- => True
> 4 `elem` [1, 2, 3] -- => False

> zip [1, 2, 3] [4, 5, 6] -- => [(1, 4), (2, 5), (3, 6)]

-- списъците могат да бъдат сравнявани един с друг,
-- ако техните елементи могат да бъдат сравнявани
-- <, <=, > и >= правят лексигокрафско сравнение
> [3, 2, 1] > [2, 1, 0] -- => True  
> [3, 2, 1] > [2, 10, 100] -- => True
> [3, 4, 2] > [3, 4] -- => True
> [3, 4, 2] > [2, 4] -- => True
> [3, 4, 2] == [3,4,2] -- => True

-- низовете са всъщност списъци от символи
-- type String = [Char]
-- можем да работим с низове, както със списъци
> "hello" ++ " " ++ "world"  -- => "hello world"
> ['h', 'e'] ++ ['l', 'l', 'o'] -- => "hello"
> 'a':" cute llama" -- => "a cute llama"
>  "a cute llama"!! 6 -- => 'e'
```

## Генератори на списъци

### Range
```haskell
-- чрез range можем да генерираме списъци,
-- които представяват аритметична прогресия
-- (има някаква дефинирана последователност над елементите)
> [1..5] -- => [1, 2, 3, 4, 5]
> ['a'..'e'] -- => "abcde"

-- можем да зададем стъпка (в този случай +2)
> [2,4..10] -- => [2, 4, 6, 8, 10]  
-- стъпка -1
> [5,4..1] -- => [5,4,3,2,1]

-- препоръчително е да не нецелочислени числа в range
> [0.1, 0.3 .. 1] -- => [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]  
```

### Set Comprehension

![Set Notion](./set-notion.png)

```haskell
-- [1..5] ни е "входното множество",
-- x * 2 е трансформацията над резултата
> [x * 2 | x <- [1..5]] -- => [2, 4, 6, 8, 10]

-- можем да зададем предикат, с който да филтрираме входните данни
> [x * 2 | x <- [1..5], x * 2 >= 5] -- => [6, 8, 10]

-- можем да зададем няколко предиката, всички трябва да са изпълнени
> [ x | x <- [10..15], x /= 13, x /= 14] -- => [10,11,12,15]

-- можем да вземаме данни от няколко списъка
-- така получаваме всички комбинации от елементи на двата списъка 
> [(x, y)| x <- [2, 5], y <- [8, 10]] -- => [(2,8),(2,10),(5,8),(5,10)]   
```

## Линейно обхождане на списъци

```haskell
-- пример - функция, която намира сумата на
-- елементите на даден списък с числа
sum lst =
  if (null lst)
    then 0
    else (head lst) + sum (tail lst)
```

Нищо ново тук! Oтново имаме:

- дъно - празен ли е списъкът
- рекурсивно извикване с "опашката" на списъка (списъка без първия си елемент)

## Pattern Matching (Образци)

```haskell
-- докато с guards проверявахме дали променливата ни изпълнява някакво условие,
-- с pattern matching проверяваме дали променливата ни съвпада с даден образец (и я деконструираме) 

-- когато дефинираме функции, можем да дефинираме отделно тяло за различните образци 

factorial 0 = 1                     -- pattern matching по литерал 0
factorial n = n * factorial (n - 1) -- всички случаи, в които променливата е различна от 0

-- образците се обхождат отгоре-надолу и се използва тялото на първия образец, който съвпадне с променливата
-- изреждаме най-специфичните образци първо

-- pattern matching на наредена двойка
-- вместо това
-- addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
-- addVectors a b = (fst a + fst b, snd a + snd b)  

-- можем да напишем това
-- addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)  

-- функция, която взема първия елемент на наредена тройка
-- понеже изнорираме останалите елементи, дори не им задаваме име
first :: (a, b, c) -> a  
first (x, _, _) = x

-- pattern matching на списък
sum [] = 0  
sum (x:xs) = x + sum' xs  

-- maximum' :: (Ord a) => [a] -> a  
maximum' [] = error "maximum of empty list"  
maximum' [x] = x  
maximum' (x:xs)   
    | x > maxTail = x  
    | otherwise = maxTail  
    where maxTail = maximum' xs

-- именувани образци <име>@<образец>
capital :: String -> String  
capital "" = "Empty string, whoops!"  
capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]  
```

---

## Задачи

