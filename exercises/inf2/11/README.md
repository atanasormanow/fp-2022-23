# Упражнение 11

## Безкрайни списъци

Списъците в Haskell всъщност са потоци, понеже се оценяват мързеливо.  
Можем да работим с безкрайни списъци по същия начин, по който с обикновени списъци - повечето вградени функции работят и с безкрайни списъци.

```haskell
> ones = 1 : ones
> length ones -- => няма да завърши никога
> take 5 ones -- => [1,1,1,1,1]

-- дефинираме поток от естествени числа
> nats = [0..]
> take 5 [0..] -- => [0,1,2,3,4]

-- можем да използваме отделяне на списъци (list comprehension)
-- с генератори - безкрайни списъци
> oddSquares = [ x^2 | x <- [1,3..]]
> take 5 oddSquares -- => [1,9,25,49,81]

> pairs = [(x,y) | x <- [0..], y <- [x..]]
> take 5 pairs -- => [(0,0),(0,1),(0,2),(0,3),(0,4)]

-- много от вградените функции катo map, filter и zip
-- работят с безкрайни списъци
-- сравнение: в scheme трябваше ние ръчно да си дефинираме
-- map, filter и zip за потоци
> evens = map (\x -> x * 2) nats
> take 5 evens -- => [0,2,4,6,8]

> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
> take 5 fibs -- => [0,1,1,2,3]
```

```haskell
-- функции, за генериране на безкрайни списъци

-- repeat приема елемент x и връща безкраен списък от вида [x,x,...]
> take 5 (repeat 3) -- => [3,3,3,3,3]

-- cycle приема списък и връща безкраен списък, повтаряйки подадения (краен) списък
> take 5 (cycle [1,2,3]) -- => [1,2,3,1,2]

-- iterate приема функция f и елемент x и връща безкраен списък
-- от вида [x,f(x),f(f(x)),...]
> take 5 (iterate (\x -> x + 1) 0) -- => [0,1,2,3,4]
```

## Lambda функции

Анонимни фукнции - удобни когато фукнцията, която дефинираме се използва само на едно място. Не е нужно да им измисляме име. Обикновенно дефинираме lambda функции, за да ги подадем като аргумент на функция от по-висок ред.

```haskell
-- (\arg1 arg2 ... -> body) 

-- функция, която при подадено число, връща следващото
(\x -> x + 1)

-- lambda функциите могат да бъдат извикани с аргументи 
-- веднага след дефиницията си
> (\x -> x + 1) 1 -- => 2

-- можем да деконструираме аргументите на lambda
-- функцията чрез използване на образци (pattern matching)
> (\(a,b) -> a + b) (1,2) -- => 3
```

## Функции от по-висок ред над списъци

```haskell
-- map приема функция и списък
-- прилага функцията над всеки елемент от подадения списък
-- връща нов списък
-- синтаксис: map function lst
map (\x -> x ^ 2) [1,2,3] -- => [1,4,9]

-- filter приема функция-предикат и списък
-- премахва елементите от списъка, които не изпълняват подаденото условие
-- връща нов списък
-- синтаксис: filter predicate lst
filter odd [1,2,3] -- => [1,3]

-- foldr (дясно свиване) приема функция, нулева стойност и списък
-- прилага подадената функция над елементите на list отдясно-наляво
-- синтаксис: foldr function null-value lst

-- foldr function null-value '[a1 a2 a3 .. an] е еквивалентно на
-- (a1 function (a2 function (a3 function (... (an function null-value)))))
> foldr (+) 0 [1,2,3] -- => 6
> foldr (\x result -> x : result) [] [1,2,3] -- => [1,2,3]
> foldr1 max [1,2,3] -- => 3

-- foldl (ляво свиване) приема функция, нулева стойност и списък
-- прилага подадената функция над елементите на list отляво-надясно
-- ситанксис: foldl function null-value lst

-- foldl function null-value '(a1 a2 a3 .. an) е еквивалентно на
-- ((((null-value function a1) function a2) ...) function an)
> foldl (+) 0 [1,2,3] -- => 6
> foldl (\result x -> x : result) [] [1,2,3] -- => [3,2,1]
> foldl1 max [1,2,3] -- => 3

-- zipWith приема функция и 2 списъка
-- комбинира елементите им поиндексно като прилага подадената функция над тях
-- връща нов списък
> zipWith (+) [1,2,3] [4,5,6] -- => [5,7,9]

> takeWhile (\x -> x <= 3) [1,2,3,4,5] -- => [1,2,3]
> dropWhile (\x -> x <= 3) [1,2,3,4,5] -- => [4,5]
```

---

## Задачи

1. Дефинирайте фунцкия `zipWith' func lst1 lst2`, която комбинира елементите на подаените списъци поиндексно като прилага func над тях

    ```haskell
    > zipWith' (+) [1,2,3] [4,5,6] -- => [5,7,9]
    ```

2. Дефинирайте функция `quicksort`, която сортира списък

    ```haskell
    > quicksort [6,3,4,2,5,1] -- => [1,2,3,4,5,6]
    ```

3. Дефинирайте функция `subsets`, която намира всички "подмножества" на подаденото

4. Дефинирайте функция `from n`, която връща безкраен списък от вида `[n, n+1, n+2, n+3, ...]`

    ```haskell
    > take 5 (from 0) -- => [0,1,2,3,4]
    ```

5. Дефинирайте безкрайния списък `primes` от прости числа

    ```haskell
    > take 5 primes -- => [2,3,5,7,11]
    ```

6. Дефинирайте безкраен списък `pythagoreanTriples` от всички питагорови тройки. Питагорова тройка е наредена тройка `(a,b,c)`, за която $a^2 + b^2 = c^2$.  
Упътване: използвайте [list comprehension](../10/README.md#отделяне-на-списъци-list-comprehension)

    ```haskell
    > take 5 pythagoreanTriples
    ```

7. Дефинирайте `facts` - безкраен списък, в който n-тия елемент е n! 

    ```haskell
    > take 7 facts -- => [1,1,2,6,24,120,720]
    ```

8. Дефинирайте функция `sumLast`, която приема две положителни естествени числа $k$ и $n$ и генерира безкрайния поток, в който първото число е $k$, а всяко следващо число е равно на сумата от предходните $n$ числа в потока.

    ```haskell
    > take 8 (sumLast 3 5) -- => [3,3,6,12,24,48,93,183]
    ```