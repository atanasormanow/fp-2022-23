Седмица 8
========

Задачи върху графи
--------

### Задача 1
Да се напише предикат, който проверява дали има път между два върха

### Задача 2
Да се напише функция, която връща най-късия път между два върха

### Задача 3
Да се напише предикат, който връща истина, ако даден граф е двуделен и лъжа иначе

Теория
------

## Отложени операции:
Има случаи на тежки операции, които могат да отнемат много време за изпълнение. В такъва ситуации е удобно да имаме механизъм за подготвяне операциите и да ги изпълняваме само при нужда. Функция, която ще изчисли и върне някаква стойност в бъдещ момент
от изпълнението на програмата се нарича promise (обещание) или отложена операция. 

Функции за работа с promise:
- `(delay <израз>)` - създава promise за оценяването на <израз>
- `(force <promise>)` - оценява израза свързан с дадения promise



## Потоци: 
Празен списък или наредена двойка от (<елемент> . <promise за поток>)

Тъй като в R5RS няма вградени функции за работа с потоци, можем да си ги дефинираме използвайки force & delay

```Racket
(define empty-stream '())
(define empty-stream? null?)
(define (cons-stream a b) 
  (cons a (delay b))
)

(define head car)
(define (tail s) 
  (force (cdr s))
)
```

Горната дефиниция обаче има проблем. Идеята на потоците е, че можем да конструираме списък, от който взимаме елемент по елемент като всеки един от тях ще бъде оценяван при нужда. С горната дефиниция обаче, това не е възможно поради стандартното правилото за оценяване. 
Пример:
`(cons-stream 5 (cons-stream (fibonacci 100000000000) empty-stream))`
В истински поток, би трябвало това да се създаде мигновено, а изчисляването на фибоначи да остане, за когато ни потрябва. В нашия случай обаче, cons-stream иска да оцени и двата си аргумента преди да се извиква. Това означава, че cons-stream трябва да бъде специална форма.


## Дефиниране на специални форми:

Синтаксисът за дефиниране на специални форми е:
```Racket
(define-syntax <символ>
  (syntax-rules () {(<шаблон> <тяло>)})
)
```

Така дефинираме специална форма <символ>, която заменя всяко срещане на <шаблон> с <тяло>.

Вече можем да си дефинираме и `cons-stream` по следния начин:
```Racket
(define-syntax cons-stream
  (syntax-rules () ((cons-stream a b) (cons a (delay b))))
)
```

Задачи върху потоци
-------

### Задача 1
Да се напише функция, която връща поток от всички естествени числа

### Задача 2
Да се напише функция, която връща поток от числата на фибоначи

### Задача 3
Да се напишат функциите `map` & `filter` да работят върху потоци

### Задача 4
Да се напишат функциите take & drop да работят върху потоци

### Задача 5
Да се напише функция, която правим безкраен поток от вида (x f(x) f(f(x)) f(f(f(x))) ...)

### Задача 6
Да се напише функция, която по даден поток и индекс n, намира елемента на потока на позиция n.
