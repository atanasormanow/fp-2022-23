Седмица 7
========

Теория:
-------
- Двоични дървета
- Асоциативни списъци
- Графи

## Двоични дървета

За двоично дърво можем да дадем следната индуктивна дефиниция
- Празният списък е дърво (празното дърво)
- Списък с 3 елемента от вида `(node left-tree right-tree)` е дърво, където `left-tree` & `right-tree` са дървета

Разглеждайки го в контекста на Scheme, примери за дървета са:
```Racket
'() ; празното дърво
'(1 () ()) ; дърво с един елемент
'(2 (3 (5 () ()) (4 () ())) (4 () ())) ; Дърво изглеждащо по следния начин

          2
        /   \
       3     4
      / \
     5   4
```

Можем да си дефинираме няколко функции за работа с дървета:

```Racket
(define empty-tree '())
(define empty-tree? null?)

(define root car)
(define left-tree cadr)
(define right-tree caddr)

(define (tree node left-tree right-tree) 
  (list node left-tree right-tree)
)
(define (tree? t)
  (or 
    (empty-tree? t)
    (and 
      (list? t)
      (= (length t) 3)
      (tree? (left-tree t))
      (tree? (right-tree t))))
) 

(define (leaf x) (tree x empty-tree empty-tree))
(define (leaf? t) 
  (and 
    (tree? t) 
    (empty-tree? (right-tree t)) 
    (empty-tree? (left-tree t)))
)
```

Използвайки тези дефиниции, постигаме едно ниво на абстракция и представяне на структура от данни чрез основни неща

### Асоциативни списъци
Асоциативните списъци (познати още като hash, map, dictionary) са списъци от наредени двойки от тип <key, value> като съпоставяме на даден ключ някаква стойност. 

```Racket
'() ; празен асоциативен списък
'((1 . 3) (4 . 5) (2 . 8)) ; Асоциативен списък, в който съпоставяме на:
1 -> 3
4 -> 5
2 -> 8
```

Можем да си дефинираме тези 2 функции, които да ни улеснят работата с асоциативни списъци, а останалите ще направим за упражнение

```Racket
(define (keys alist) (map car alist)) ; списък от ключовете в асоциативния списък
(define (values alist) (map cdr alist)) ; списък от стойностите в асоциативния списък
```

### Графи
Графите можем да представим чрез списък на съсетство, т.е. асоциативен списък, в който на всеки връх съпоставяме списък от съседите му.

```Racket
'((5 2 3) (2 5 1) (3 1 4))

5 ↔ 2
↓   ↓
3 → 1
↓
4
```

Задачи:
-------
#### Зад. 1
Да се напише функция, която премахва елемент от асоциативен списък

#### Зад. 2
Да се напише функция, която добавя елемент в асоциативен списък (ако елемент с този ключ съществува - трябва да бъде заменен)

#### Зад. 3
Да се напише функция, която търси елемент в асоциативен списък. Ако такъв съществува, връща наредената двойка <key, value> за даденият ключ, #f в противен случай.

#### Зад. 4
Да се напише функция, която търси елемент в дърво. Ако такъв съществува - връща поддървото с корен търсеният елемент и #f в противен случай. 

#### Зад. 5
Да се напише функция, която връща височината на дадено дърво

#### Зад. 6
Да се напише функция, която сумира елементите на дърво

#### Зад. 7
Да се напише функция, която сумира листата на дърво

#### Зад. 8
Да се напише функция, която намира най-големият елемент на дърво

#### Зад. 9 
Да се напише предикат, който проверява дали дадено двоично дърво е пълно двоично дърво

#### Зад. 10

