# Бонус задачи за списъци "за любознателните"

### Зад.1
Да се напише функция `(subsets lst)`, която генерира списъка от всички подмножества на елементите на даден списък. Редът на подмножествата в резултата е без значение:
```
(subsets '(1 2 3)) -> '(() (1) (2) (3) (1 2) (1 3) (1 2 3))
```
_Бонус:_ подмножествата да се генерират в лексикографска наредба (както в горния пример)

### Зад.2
Да се напише функция `(permutations lst)`, която генерира списъка от всички пермутации на даден списък. Редът на пермутациите в резултата е без значение:
```
(permutations '(1 2 3)) -> '((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))
```
_Бонус:_ пермутациите да се генерират в лексикографска наредба (както в горния пример)

### Зад.3
Да се напише функция `(next-perm lst)` или `(prev-perm lst)`, която по даден списък да връща лексикографски* следващата/предишната негова пермутация, или `#f` ако такава няма (текущата е последната/първата в наредбата):
```
(next-perm '(2 1 3)) -> '(2 3 1)
(next-perm '(3 2 1)) -> #f
```
\* Заради асиметричната структура на списъците в Scheme може да се окаже, че е по-удобно да се генерират в *колексикографска* наредба (четена от дясно наляво) - оставяме на Вас да експериментирате кое представяне води до по-лесна имплементация :) Целта е да можем да "итерираме" удобно всички пермутации, т.е. ...

### Зад.4
... да се използват функциите от горната задача за генериране на списъка от всички пермутации на даден списък (в какъвто ред се генерират оттам)

### Зад.5
Да се напише функция `(longest-incr lst)`, която връща максимално дълга нарастваща подредица от елементите на даден списък. Тази подредица не е задължително да включва последователни елементи на списъка, или да е уникална, но е важно да запазва оригиналната наредба на елементите:
```
(longest-incr '(2 0 1 3 8 4 5 9 6 5 8)) -> '(0 1 3 4 5 6 8)
;участващи ел-ти: ^ ^ ^   ^ ^   ^   ^
```
