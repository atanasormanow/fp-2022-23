#lang racket

; Предния път работихме със списъци и реализирахме
; функцията accumulate

; В racket (и Haskell) има 2 различни но много близки
; помежду си имплементации:

(foldr + 0 '(1 2 3 4)) ; 10
(foldl + 0 '(1 2 3 4)) ; 10

; Каква е разликата тогава?

; foldr сгъва списъка от дясно наляво
;------------------------------------
; (+ 1 (+ 2 (+ 3 (+ 4 0))))
; foldr генерира рекурсивен процес и тези операции са
; отложени

; т.е. можете да се възползвате от това,
; ако искате операциите ви да се изпълнят в обратен ред

; foldl сгъва списъка от ляво надясно
;------------------------------------
; (+ 4 (+ 3 (+ 2 (+ 1 0))))
; foldl генерира итеративен процес и операциите се
; изчисляват в аргумента.

; NOTE: Нормалния foldl (както работи и в Haskell)
;       има по-различна имплементация:
;       (+ (+ (+ (+ 0 1) 2) 3) 4)
; Разликата е в реда на аргументите на операцията.

; В Racket:
; (foldl - 0 '(1 2 3 4)) -> 2
; (4 - (3 - (2 - (1 - 0))))

; В Haskell:
; (foldl - 0 '(1 2 3 4)) -> -10
; ((((0 - 1) - 2) - 3) - 4)


; В scheme има функции, които могат да приемат произволен
; брой аргументи.
;----------------
; map на много аргументи
(map + '(1 2 3) '(4 5 6)) ; '(5 7 9)
; списъците трябва да имат еднаква дължина

; apply прилага функция над списък от аргументи
(apply + '(1 2 3 4 5)) ; 15
(apply max '(1 2 3 11 4 5)) ; 11

; apply има вида: (apply proc v1 ... vn lst kw-arg ...)
; Засега не се интересуваме от kw-arg.
; Освен подадения списък, apply може да приема и
; допълнителни аргументи към подадената процедура proc.
; Това са онези v1 ... vn

; Тук 2 е допълнителен аргумент към *
(apply * 2 '(1 2 3)) ; 12
; същото като:
(* 2 1 2 3)

; Тук + е допълнителен аргумент към map:
(apply map + '((1 2 3) (4 5 6))) ; '(5 7 9)
; същото като:
(map + '(1 2 3) '(4 5 6))

; Ето и един пример с транспониране на матрица
(define (transpose m)
  (apply map list m))

; Разписваме transpose:
;
; (define m '((1 2 3)
;             (4 5 6)
;             (7 8 9)))
;
; (apply map list '((1 2 3) (4 5 6) (7 8 9)))
; <=>
; (map list '(1 2 3) '(4 5 6) '(7 8 9))
; <=>
; (list (list 1 4 7)
;       (list 2 5 8)
;       (list 3 6 9))

; Можем да правим функции на произволен брой аргументи
; (lambda (<args> . <opt-args>) <body>)
; Където <args> са задължителните параметри,
; а opt-args е списък с допълнителни (optional) аргументи.
(lambda (x . lst) (apply + (cons x lst)))

; Вече знаем че define е синтактична захар за свързване
; на име с ламбда.
; Съответно дефинираме такива функции с define така:
(define (sum x . l) (foldl + 0 (cons x l)))


;===============;=========================================
;; З А Д А Ч И ;;
;;;;;;;;;;;;;;;;;

; 0. Като foldl но рекурсивно
; Пример: (foldr* - 0 '(1 2 3 4)) -> -2
(define (foldr* op acc lst) 'undefined)

; Използвайте foldl или foldr:
;-----------------------------
; 1. Намира дължина на списък
(define (length* lst) 'undefined)

; 2. Премахва повторенията на елементи в lst
(define (uniques lst) 'undefined)

; 3. Проверява дали p? е верен за точно n елемента от lst
(define (sat-n? p? n lst) 'undefined)

; 4. Връща списък с елементите на lst, но в обратен ред.
(define (reverse* lst) 'undefined)

; 5. Намира броя на елементите в дълбокия списък lst.
; Тоест lst може да има произволни нива на вложеност.
(define (count-atoms lst) 'undefined)

; 6. Връща наредена двойка (fst . snd), където
; fst са елементите за които p? е истина
; и snd са тези за които p? е лъжа
(define (partition* p? lst) 'undefined)

; Използвайте apply:
;-------------------
; 7. Средно аритметично на много аргументи
(define (avg h . t) 'undefined)

; 8. Композиция на на много едноаргументни функции
(define (compose-all f . gs) 'undefined)

; 9. Конюнкция на много едноместни предикати
(define (conjoint-all p? . preds) 'undefined)

; 10. Като map на много аргументи, но трябва да работи за
; списъци с различни дължини.
(define (zipWith f . lsts) 'undefined)
