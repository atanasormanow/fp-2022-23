# 07. Асоциативни списъци. Графи. Потоци

Забележка: задачите за асоц. списъци са същите от 06 упражнение.

## Асоциативни списъци
1. Напишете функция `(index l)`, която връща асоциативен списък, в който всеки елемент `x` на `l` е асоцииран с ключ, равен на позицията на `x` в `l`.

2. Напишете функция `(histogram l)`, която
   връща хистограма на срещанията на всички елементи в `l` под формата на асоциативен списък.

   Например, `(histogram '(8 7 1 7 8 2 2 8 2 7 8 1))`
   връща асоциативния списък `'((8 . 4) (7 . 3) (1 . 2) (2 . 3))`.

1. Напишете функция, която в асоциативен списък изчиства дублирани ключове, като запазва само първата стойност.

1. Напишете функция, която слива два асоциативни списъка, като за общите ключове прилага двуместна операция подадена като аргумент.

1. Напишете функция, която композира два асоциативни списъка с целочислени ключове и стойности, разглеждайки ги като функции.
   Пример:
   ```scheme
   (compose '((1 . 2) (2 . 3) (3 . 4)) ((2 . 20) (4 . 40) (6 . 60))) ; да връща ((1 . 20) (3 . 40))
   ```

   Разглеждайки асоциативните списъци като множества от наредени двойки, композицията на `al1` и `al2` е:
    { <x, z> | <x, y> ∈ al1 & <y, z> ∈ al2 }

3. Напишете функция `(group-by f l)`, която
   връща асоциативен списък, в който ключовете са стойностите на функцията `f` след прилагането ѝ върху елементи от списъка `l`, а
   срещу ключовете стои списък от елементите, за които функцията `f` дава стойността от ключа.

   Например, `(group-by (lambda (x) (remainder x 3)) '(0 1 2 3 4 5 6 7 8))`
   връща асоциативния списък `'((0 0 3 6) (1 1 4 7) (2 2 5 8))`.

1. Напишете функция `(run-length-encode l)`, която
   кодира списъка `l` в асоциативен списък - списък от наредени двойки `'(<ключ> . <стойност>)`,
   където `<ключ>`-ът e пореден елемент от списъка `l`, а
   `<стойност>`-та е колко пъти се повтаря елемента последователно.

   Например, `(run-length-encode '(8 7 7 2 2 2 2 3 3 2))`
   връща асоциативния списък `'((8 . 1) (7 . 2) (2 . 4) (3 . 2) (2 . 1))`.

2. Напишете функция `(run-length-decode code)`, която
   възстановява списъка, който е кодиран чрез `run-length-encode` от предната задача
   в асоциативния списък `code`.

   Например, `(run-length-decode '((1 . 2) (3 . 4) (5 . 2)))`
   връща `'(1 1 3 3 3 3 5 5)`.

## Графи
1. Напишете функции `(indegree v g)` и `(outdegree v g)`, които намират съответно полустепените на входа и изхода за връх `v` от граф `g`.

1. Да се напише функция `(predecessors v g)`, която връща списък с всички предшественици на върха v в графа g:
```
(predecessors 'e G) -> '(b f)
```

1. Напишете функция `(graph-transpose g)`, която връща [транспонирания][t1] граф на `g`.

[t1]: https://en.wikipedia.org/wiki/Transpose_graph

3. Напишете функция `(acyclic? g)`, която проверява дали графът `g` е ацикличен, тоест няма цикъл.

4. Напишете функция `(shortest-path g u v)`, която намира най-късият път от върха `u` до върха `v` в графа `g`.
> Упътване: тъй като боравим с графи без тегла, най-късият път от `u` до `v` се намира като пуснем `bfs` в `u`.

## Потоци
1. Дефинирайте `ones` - поток от единици: `[1,1,1,1,1,1,1,...]`

2. Дефинирайте `nats` - потокът на естествените числа: `[0,1,2,3,...]`

3. Напишете функция `from`, която приема число и връща потокът със всички естествени числа п-големи или равни на числото.
   ```scheme
   (from 5) -> [5,6,7,8,9,10,...]
   ```

4. Дефинирайте `fibs` - потокът на числата на фибоначи: `[0,1,1,2,3,5,8,13,...]`

5. Дефинирайте `primes` - потокът на простите числа: `[2,3,5,7,11,13,...]`
> Упътване: можете да ползвате [решето на Ератостен][sieve]

[sieve]: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes

6. Дефинирайте `pythagorean-triples` - поток от Питагоровите тройки. Питагорова тройка е наредена тройка (a, b, c), за която a^2 + b^2 = c^2.


## Задачи от контролни
### Задача 2 (8 т.) от 2016/17
[Scheme/Haskell] Да се напише функция multLast, която
приема две положителни естествени числа  k и  n и генерира безкрайния
поток,  в  който  първото  число  е  k,  а  всяко  следващо  число  е
произведението от предходните n числа в потока.
Пример:
```hs
multLast 2 3 → [2, 4, 8, 64, 2048, … ]
```
### Задача  3  (8  т.) от 2016/17
[Scheme/Haskell] Нека  е  даден  ориентиран  граф  със
символи  по  върховете  и  целочислени  тегла  по  върховете,  който  е
представен чрез списъци от наследници по следния начин:

Scheme:
```scheme
(define G ‘((a 2 b c)))
            (b 4 a c)))
            (c 1 a b))))
```
Haskell:
```hs
g :: [(Char, Int, [Char])]
g = [('a', 2, "bc"]),
     ('b', 4, "ac"),
     ('c', 1, "ab")]
```
Да  се  напише  функция  eulerPathCost,  която  проверява  дали  графът
съдържа  Ойлеров  път,  който  не  е  цикъл,  и ако  да,  връща  цената  му
(сборът от теглата на върховете, през които минава), а ако не, връща 0.

### Задача 3 от 2017/18
Телевизионно предаване се представя с наредена тройка от име
(низ), начален час (наредена двойка от час и минути) и продължителност
(брой  минути).  Телевизионна  програма  наричаме  последователност  от
предавания, чиито интервали на излъчвания са подредени в нарастващ ред
и не се пресичат.
1.
(5 т.) Да се напише функция isProgram, което проверява дали даден
списък от предавания е телевизионна програма.
2.
(10 т.) Да се напише функция  diversestProgram, която по даден
списък  от  телевизионни  предавания  генерира  възможно  най-
разнообразна телевизионна програма, т.е. броят на различните (по
име) предавания в нея е в максимален.
Пример:
shows = [(“A”,(10,30),90),(“B”,(11,0),120)),(“C”,(12,0),15)]
isProgram shows → False
diversestProgram shows → [(“A”,(10,30),90),(“C”,(12,0),15)]⏎
