# 06. Структури от данни - матрици, дървета и асоциативни списъци

[Матрици](#матрици), [Двоични дървета](#двоични-дървета), [Асоциативни списъци](#асоциативни-списъци)

## Матрици
1. Напишете функция `(matrix-ref m i j)`,
   която връща елемент на позиция `i, j` в матрицата `m`.
   Пример: `(matrix-ref '((1 2 3) (4 5 6) (7 8 9)) 2 1) -> 8`

3. Напишете функция `(mat? m)`, която валидира, че m е матрица
   (всички елементи числа; редовете са с равни дължини)

1. Напишете функция `(delete-column i m)`, която връща матрица, представляваща `m`
   без `i`-тата си колона:
   ```scheme
   (delete-column 1 '((1 2 3 5)
                      (6 7 8 0)
                      (5 6 3 4)))
   -> '((1 3 5)
        (6 8 0)
        (5 3 4))
   ```

1. Напишете функция `(transpose m)`, която транспонира матрица.
   ```scheme
   (transpose '((1 2 3) (4 5 6) (7 8 9))) -> '((1 4 7) (2 5 8) (3 6 9))
   ```
1. Напишете функция `(map-matrix f m)`, която прилага `f` върху всеки от елементите на `m`.
1. Напишете функция `(main-diagonal m)`, която връща главния диагонал на матрицата `m`.
   ```scheme
   (main-diagonal '((1 2 3)
                    (4 5 6))) ; -> '(1 5)
   ```

1. Напишете функция `(dimensions m)`, която
връща наредена двойка с броя редове и броя колони на матрицата `m`.

   Например, `(dimensions '((1 2 3) (4 5 6)))` връща `'(2 . 3)`.

2. Напишете функция `(reverse-columns m)`, която
обръща реда на колоните в матрицата `m`.

   Например, `(reverse-columns '((1 2 3) (4 5 6) (7 8 9)))`
   връща `'((3 2 1) (6 5 4) (9 8 7))`.

3. Напишете функция `(nth-column m n)`, която
връща списък с елементите на `n`-тата поред колона от матрицата `m`.

   Например, `(nth-column '((1 2 3) (4 5 6) (7 8 9)) 2)` връща `'(2 5 8)`.

6. Напишете предикат `(all-columns? p? m)`, който
проверява дали за всяка колона в матрицата `m` е изпълнен предикатът `p`.

7. Напишете предикат `(prime-in-each-column? m)`, който
проверява дали във всяка колона в матрицата `m` има просто число.

    Например, `(prime-in-each-column? '((2 2 4) (4 5 6)))` e `#f`.

    Но `(prime-in-each-column? '((17 2 16) (4 5 3)))` e `#t`.

8. Напишете функция `(multiply m1 m2)`, която
връща произведението на двете матрици `m1` и `m2`.

9. Напишете функция `(find-columns m)`, която
намира броят на колоните, за които е вярно, че
всичките им елементи се срещат в някой от редовете на матрицата.

    Например `(find-columns '((1 4 3) (4 5 6) (7 4 9)))` връща `1`,
    защото `4`, `5` и `4` от втората колона се срещат във втория ред.

## Двоични дървета
1. Абстракция: `(make-tree root left right)`, `(root-tree tree)`, `(left-tree tree)`,
   `(right-tree tree)`, `(empty-tree? tree)`, `(leaf-tree? tree)`, `(tree? x)`

1. Напишете функции `(collect-pre-order t)`, `(collect-in-order t)` и `(collect-post-order t)`, които връща списък от елементите на дървото, обходено съотвено `корен-ляво-дясно`, `ляво-корен-дясно` и `ляво-дясно-корен`.

6. Напишете функция `(map-tree f t)`, която заменя всеки връх `x` от дървото `t` с `(f x)`.

1. Напишете функция `(height)`, която намира височината на дървото `t`. Това е броят на върховете в най-дългия път.

1. Напишете функция `(level n t)`, която връща списък с всички върхове от дървото с дълбочина `n`.
> Дълбочината на един връх `x` от дърво е броят ребра, които го свързват с корена `r`. Това е равно и на броя върхове от `r` до `x`, без да броим `x`. Дълбочината на корена е 0.

4. Напишете функция `(count-leaves t)`, която връща броя листа на t.
> Листо е връх от дърво, който няма наследници.

5. Напишете функция `(remove-leaves t)`, която връща дървото t, премахвайки листата му.

1. Напишете функция `(invert t)`, която разменя левите поддървета на `t` с десните.

1. Напишете функция `(bst? t)`, която намира дали `t` двоично **наредено** дърво.

1. Напишете функция `(insert-bst x t)`, която добавя елемент `x` в двоично **наредено** дърво `t`, запазвайки наредбата му.
> Така може да направите функция `(list->bst l)`, която по списък прави наредено дърво, и чрез някоя от `collect` функциите от задачa 1 може да реализирате сортиране на списък.

1. Двоично дърво е балансирано, ако:
   1. е празното двоично дърво или
   2. височините на лявото и дясното поддърво се различават най-много с 1 и
   лявото и дясното поддървета са балансирани.

   Напишете предикат `(balanced? tree)`, която
   проверява дали дървото `tree` е балансирано.


## Асоциативни списъци
1. Напишете функция `(index l)`, която връща асоциативен списък, в който всеки елемент `x` на `l` е асоцииран с ключ, равен на позицията на `x` в `l`.

2. Напишете функция `(histogram l)`, която
   връща хистограма на срещанията на всички елементи в `l` под формата на асоциативен списък.

   Например, `(histogram '(8 7 1 7 8 2 2 8 2 7 8 1))`
   връща асоциативния списък `'((8 . 4) (7 . 3) (1 . 2) (2 . 3))`.

1. Напишете функция, която в асоциативен списък изчиства дублирани ключове, като запазва само първата стойност.

1. Напишете функция, която слива два асоциативни списъка, като за общите ключове прилага двуместна операция подадена като аргумент.

1. Напишете функция, която композира два асоциативни списъка с целочислени ключове и стойности, разглеждайки ги като функции.
   Пример:
   ```scheme
   (compose '((1 . 2) (2 . 3) (3 . 4)) ((2 . 20) (4 . 40) (6 . 60))) ; да връща ((1 . 20) (3 . 40))
   ```

   Разглеждайки асоциативните списъци като множества от наредени двойки, композицията на `al1` и `al2` е:
    { <x, z> | <x, y> ∈ al1 & <y, z> ∈ al2 }

3. Напишете функция `(group-by f l)`, която
   връща асоциативен списък, в който ключовете са стойностите на функцията `f` след прилагането ѝ върху елементи от списъка `l`, а
   срещу ключовете стои списък от елементите, за които функцията `f` дава стойността от ключа.

   Например, `(group-by (lambda (x) (remainder x 3)) '(0 1 2 3 4 5 6 7 8))`
   връща асоциативния списък `'((0 0 3 6) (1 1 4 7) (2 2 5 8))`.

1. Напишете функция `(run-length-encode l)`, която
   кодира списъка `l` в асоциативен списък - списък от наредени двойки `'(<ключ> . <стойност>)`,
   където `<ключ>`-ът e пореден елемент от списъка `l`, а
   `<стойност>`-та е колко пъти се повтаря елемента последователно.

   Например, `(run-length-encode '(8 7 7 2 2 2 2 3 3 2))`
   връща асоциативния списък `'((8 . 1) (7 . 2) (2 . 4) (3 . 2) (2 . 1))`.

2. Напишете функция `(run-length-decode code)`, която
   възстановява списъка, който е кодиран чрез `run-length-encode` от предната задача
   в асоциативния списък `code`.

   Например, `(run-length-decode '((1 . 2) (3 . 4) (5 . 2)))`
   връща `'(1 1 3 3 3 3 5 5)`.


## Задачи от контролни

### Задача 1. (10 т.) от 2017/18
Да се напише функция extremum, която по даден списък от
списъци от числа намира число, което е минимално или максимално във
всеки от списъците, ако има такова, или 0 иначе.
Пример: extremum [[1,2,3,2],[3,5],[3,3],[1,1,3,3]] → 3
Пример: extremum [[1,2,3,2],[2,3,5],[3,3],[2,2,3,3]] → 0
### Задача 2. от 2017/18
1. (6 т.) Да се напише функция clone t x y, която по дадено двоично
   дърво  от  числа  t получава  ново  със  зададен  корен  x и  две
   поддървета,  получени  от  t чрез  увеличаване  на  всичките  му
   елементи със зададено число y.
2. (6 т.) Двоично дърво наричаме “пълно”, ако има 2n елемента на ниво
   n. Да се напише функция  cloningTrees, която генерира безкраен
   поток от пълни дървета с височини съответно 1, 2, 3,..., като всички
   елементи на ниво n са със стойност n.

### Задача 3 от 2017/18
Телевизионно предаване се представя с наредена тройка от име
(низ), начален час (наредена двойка от час и минути) и продължителност
(брой  минути).  Телевизионна  програма  наричаме  последователност  от
предавания, чиито интервали на излъчвания са подредени в нарастващ ред
и не се пресичат.
1. (5 т.) Да се напише функция isProgram, което проверява дали даден
   списък от предавания е телевизионна програма.
2. (10 т.) Да се напише функция  diversestProgram, която по даден
   списък  от  телевизионни  предавания  генерира  възможно  най-
   разнообразна телевизионна програма, т.е. броят на различните (по
   име) предавания в нея е в максимален.

   Пример:
   ```
   shows = [(“A”,(10,30),90),(“B”,(11,0),120)),(“C”,(12,0),15)]
   isProgram shows → False
   diversestProgram shows → [(“A”,(10,30),90),(“C”,(12,0),15)]
   ```

### Задача 4 (8 т.) [Scheme] от 2016/17
Да се напише функция  transformCount, която
преобразува  дърво  с  елементи  цели  числа  в  ново  дърво  със  същата
структура,  в  което  всеки  елемент  е  заменен  с  броя  на  елементите  в
поддървото с този корен в началното дърво.

Бонус (4 т.): transformCount да работи в O(n) време в най-лошия случай.
