# Кортежи, списъци, работа със списъци, функции от по-висок ред


## Наредени n-торки (кортежи)
- могат да съдържат различни типове данни, но всяка n-торка си има тип, например `(Int, String)`
- могат да се сравняват, ако типовете на елементите им са сравними
- за **наредена двойка** - можем да достъпим елементите ѝ с функциите `fst` и `snd`.
- деконструиране - ако една функция приема наредена n-торка като аргумент, може да именуваме частите ѝ и да ги използваме наготово.
- пример:
```
getFirsts :: (a, b) -> (c, d) -> (a, c)
getFirsts tuple1 tuple2 = ((fst tuple1), (fst tuple2))

getFirsts' :: (a, b) -> (c, d) -> (a, c)
getFirsts' (x1,x2) (y1,y2) = (x1, y1)

getFirsts'' :: (a, b) -> (c, d) -> (a, c)
getFirsts'' (x1,_) (y1,_) = (x1, y1)
```
## Списъци

- Пишем ги в квадратни скоби и изредени със запетайка, задължително от един тип
- Типът на списък от нещо е `[<нещо>]`
- String = [Char]
- Имаме стандартни функции за работа със списъци:
```
length
:
sum
product
++ (append)
null - проверка за празен списък
head - взима първия елемент
tail - взима опашката
last - връща последния елемент
init - премахва последния елемент
lst !! 1 - като list-ref в scheme (lst e име на списък)
reverse
take
drop
elem - проверява дали х е елемент на списък
```
- Range - можем да генерираме прости списъци по следния начин:
```
[1..10]
[10..1] - така не става -> [10,9..1]
[1, 1..] - безкраен поток
[2, 4..30]
[‘a’,’b’..’z’]
ones = 1 : ones - друг вариант за безкраен поток
```
- Пример за намиране на дължина на списък:
```
length' :: [a] -> Int
length’ lst : if null lst then 0 else 1 + length' (tail lst)

length'' :: [a] -> Int
length'' [] = 0
length'' (_:xs) = 1 + length'' xs

length''' :: [a] -> Int
length''' lst = sum [1| _ <- lst]
```
- Последният пример използва list comprehension или работа с генератори. Можем да мислим за него като дефиницията на множество, например S = {a | a < 10}. Пример:
```
sumEvens :: [Int] -> Int
sumEvens lst = sum [x | x <- lst, even x]

cartesian :: [a] -> [b] -> [(a, b)]
cartesian lst1 lst2 = [(x,y) | x <- lst1, y <- lst2]
```
## Анонимни функции
изписват се по следния начин:
`(\x -> x + 1)`\
Викат се като подадем аргумент: `(\x -> x + 1) 4`\
Можем да подаваме и повече аргументи (без запетайки между тях): `(\x y -> x + y) 3 4`\
Можем да подаваме деконструирани аргументи: `(\(x:_) -> x)`


## Задачи за решаване:
```
-- first' - връща първия елемент от наредена двойка (без да използвате fst)
-- foldr' op nv lst - свиване от дясно наляво
-- sumElements lst
-- palindrome lst
-- repeatList lst - безкраен поток от елементите на lst
-- squares lst - връща списък с квадратите на числата от списък lst - с list comprehension
-- intersection lst1 lst2 - с list comprehension
-- prime х - с list comprehension
-- zipWith f lst1 lst2 - връща списък от приложена f върху а[i] от lst1 и b[i] от lst2 (покрийте случаите за различна дължина на lst1 и lst2)
-- map
-- filter
-- qsort lst
```