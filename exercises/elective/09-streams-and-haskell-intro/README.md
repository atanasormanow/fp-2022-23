# Потоци

## Отложени операции - нещо, което ще се изчисли в бъдещето (когато ни потрябва)
```
(define example (delay (+ 1 2))) ; това ще върне promise
(force example) ; ще накара promise да се изпълни
```

## Потоци
Потокът изглежда като `(<глава> . <опашка>)`, където опашка е promise. Работим с потоци по идентичен начин на работата със списъци.

## Как се дефинират функции за работа с потоци?
```
;; (define (cons-stream a b)
;;  (cons a (delay b)))
;; така няма да ни се получи^

(define-syntax cons-stream
  (syntax-rules () {(cons-stream a b) (cons a (delay b))}))
;; Така се дефинира специална форма. Тя ще ни позволи да отложим оценяването на втория аргумент на cons.

(define the-empty-stream '())

(define (stream-first str) (car str))
(define (stream-rest str) (force (cdr str)))
```

## Вградени функции за работа с потоци
### Вляво - за работа със списъци; вдясно - за работа с потоци

За да използваме функциите за потоци, сменяме езика на racket:
```
#lang racket

;; '() -> empty-stream
;; cons -> stream-cons
;; list -> stream
;; list? -> stream?
;; car -> stream-first
;; cdr -> stream-rest
;; list-ref -> stream-ref
;; null? -> stream-empty?
```

Във всеки един момент работим с някаква част от поток, затова можем без проблем да дефинираме безкрайни потоци.


## Задачи за решаване:

```
;; 1. stream-from-interval a b - връща поток от числата в затворения интервал [a,b]
;; 2. stream-to-list s - връща списък от елементите на поток s
;; 3. stream-from-list l - връща поток от елементите на списък l
;; 4. ones -> безкраен поток от единици
;; 5. n-stream -> поток от всички естествени числа, започващи от n
;; 6. my-stream-take -> поток от първите n елемента на даден поток
;; 7. add-streams s1 s2-> поток от сбора на два потока
;; 8. fib-stream -> безкраен поток от числата на Фибоначи
;; 9. repeat-list l -> прави безкраен поток от елементите на списък l
;; 10. iterate x f -> безкраен поток от типа x, f(x), f(f(x)), ...
```