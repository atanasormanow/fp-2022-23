# Упражнение 5 – Списъци и функции от по-висок ред върху тях

[код от упражнението](ex05-20221109-solutions.rkt)

### Задача 0 [разгрявка]
Припомнете си вградените функции за работа със списъци `foldr` и `foldl`. Помислете кои от задачите могат да се решат лесно, използвайки някоя от тях. Ами от задачите от предишното упражнение?

### Зад.1.
Да се напише функция `(uniques lst)`, която оставя само уникалните стойности в даден списък. Можете да проверявате за еднаквост с `equal?` за най-сигурно.
```
(uniques '(1 2 2 "iei" 1 3 "iei" 'oops)) -> '(1 2 "iei" 3 'oops) ; подредбата в резултата няма значение
```
### Зад.2.
Да се напише функция `(insert val lst)`, която вмъква стойността `val` на правилното място в сортирания в ненамаляващ ред списък `lst`:
```
(insert 5 '(1 4 10)) -> '(1 4 5 10)
(insert 12 '(1 4 10)) -> '(1 4 10 12))
```
### Зад.3.
Да се напише функция `(insertion-sort lst)`, която прави точно това, което подсказва името ѝ:
```
(insertion-sort '(4 3 6 2 1 8 10)) -> '(1 2 3 4 6 8 10)
```
### Зад.4.
Отворен числов интервал `(a;b)` се описва с наредената двойка `(a . b)`. Да се напише функция `longest-interval-subsets`, която по даден списък от интервали `il` връща нов списък, който съдържа всички интервали от `il`, които са подинтервали на най-дългия интервал в списъка.
Бонус: Функцията `longest-interval-subsets` да връща подинтервалите подредени в нарастващ ред по началната си точка.
```
(longest-interval-subsets
  '((24 . 25) (90 . 110) (0 . 100) (10 . 109) (1 . 3) (-4 . 2)))
-> ((0 . 100) (1 . 3) (24 . 25))
```
### Зад.5*.
Да се напише функция `(group-by f lst)`, която групира елементите на списъка `lst` по стойността, която `f` връща за тях. Конкретно, за всяка върната от `f` стойност над някой елемент от `lst` трябва да върнете списък с два елемента - тази стойност и списъкът от елементите на `lst`, за които се получава тя.
```
(group-by even? '(1 2 3 4 5)) -> ((#f (1 3 5))
                                  (#t (2 4))) ; подредбата няма значение
(group-by length '((1 2 3) (4) (5 6 7))) -> '((1 ((4)))
                                              (3 ((1 2 3) (5 6 7))))
```
### Зад.6.
Да се напише функция `(compose* . fns)`, която приема произволен брой функции като аргументи и връща тяхната композиция:
```
(define (sq x) (* x x))
(define (1+ x) (+ x 1))
(define f (compose* sq 1+ (lambda (x) (* x 2)) 1+))
; това е екв. на:  (sq
                      (1+
                         ((lambda (x) (* x 2))
                                              (1+ x))))
(f 5) -> 169
```
### Зад.7*.
Да се напише функция `(zipWith* f . lsts)`,  която работи аналогично на `zipWith`, но с произволен брой списъци като аргументи:
```
(zipWith* list '(1 2 3) '(a b) '(7 8 9 10)) -> '((1 a 7) (2 b 8))
(zipWith* + '(1 2 3)) -> '(1 2 3) ; все пак броят списъци е произволен
(zipWith* void) -> '() ; why does this make my head hurt
```
Упътване: можете да подавате аргументи на такъв тип функции с `apply`:
```
(apply + '(2 3 5)) <=> (+ 2 3 5) -> 10
(apply + 1 2 '(3 5)) <=> (+ 1 2 3 5) -> 11
```
