# Упражнение 13 - Алгебрични типове данни

[код от упражнението](ex13-20230111-solutions.hs)

### Зад.1.
Да се дефинира тип `Map`, който да представлява структурата от данни асоциативен списък, реализирана с двоично наредено дърво. Да се дефинират следните функции към нея:
- `mapInsert :: Ord k => k -> v -> Map k v -> Map k v` -- вмъкване на ключ със стойност в дървото. Ако стойност за този ключ съществува, нека тя да бъде заместена с новата.
- `mapSearch :: Ord k => k -> Map k v -> Maybe v`      -- търсене на стойност по ключ в дървото (обърнете внимание на върнатия тип)

### Зад.2.
Да се инстанцира класа `Functor` и за гореспоменатия тип `Map`.

_Упътване:_ кои от данните в `Map` можем да променяме и кои не? Защо?

### Зад.3.
Да се напише алгебричен тип данни `NonEmpty`, който символизира непразен списък. За него се напишат аналози на някои от най-често използваните функции за обикновени списъци (`head`, `tail`, `length`, `reverse`, `uncons`)

_Упътване:_ ако конструкторът от глава и опашка на този списък е оператор, добавете му `infixr 5` за да съвпада с `(:)`

### Зад.4*.
Да се дефинира тип дърво с произволен брой наследници на всеки възел и да се инстанцира класа от типове `Functor` за него.

### Зад.5.
Да се дефинира тип `Direction`, който да символизира посока при търсене в двоично наредено дърво (ляво или дясно). Да се дефинира функция `bstPath :: Ord a => a -> BST a => ???`, която по даден елемент и двоично наредено дърво намира пътека (последователност от посоки) до елемента в дървото.

_Упътване:_ какъв трябва да е типът на резултата?

### Зад.6.
Да се дефинира тип `Expr`, който да представлява математически израз - функция на един аргумент. Освен този аргумент, този израз може да съдържа само числа (`Double`), или следните операции: събиране, изваждане, умножение или деление на два израза. Да се дефинират следните функции към него:
- `eval :: Expr -> Double -> Double` - изчислява стойността на функцията по дадена стойност на аргумента ѝ
- `derive :: Expr -> Expr` - изчислява производната на дадена функция - тя очевидно също е функция, която искаме да можем отново да диференцираме или оценяваме точно.

### Зад.7
Да се напише функция `labelTree :: Eq a => Tree a -> Tree Int`, която заменя всеки елемент в дадено дърво с неговата поредност на срещане при ляво-корен-дясно обхождане на дървото:
```
    ┌──'c'──┐         ┌──3──┐
 ┌─'a'─┐   'b'  ->  ┌─2─┐   1
'b'   'a'           1   2

t :: Tree Char
t = Node 'c' (Node 'a' (Node 'b' Empty Empty)
                       (Node 'a' Empty Empty))
             (Node 'b' Empty Empty)
```
_Упътване:_ тук резултатът от обхождането е `['b', 'a', 'a', 'c', 'b']`, следователно `'b'` е срещнат първи, след това `'a'`, след това `'c'`.

### Зад.8**.
Горната функция да се имплементира само с едно обхождане на даденото дърво.
