; Това е коментар

; Функционалното програмиране е стил на програмиране,
; в който пишем програми като предимно прилагаме и
; композираме функции.

; Ще изучаваме 2 езика - Scheme(R5RS) и Haskell

; Scheme e диалект на LISP,
; R5RS е стандарт на Scheme със сравнително малък обем.

; Scheme:
; - динамично типизирани (стойностите имат тип)
; - нечист (със странични ефекти)
; - стриктно оценяване (първо сметни, после предай)

; Haskell:
; - статично типизирани (променливите имат тип)
; - чисти (без странични ефекти)
; - лениво (първо предай, после смятай)

;=========================================================
; Среда за програмиране - DrRacket

; Този ред е за да знае racket на какъв език пишем.
#lang racket
; Аз ще ползвам директно racket.
; Може да се фиксира и през интерфейса на DrRacket.

; Примитивни типове (константи)
; Буквен символ (char)
#\a
; Булева стойност
#t
#f
; Числа
5
-5
1/3
1+6i
; Символен низ
"asdf"
; Символи (имена)
+
=
even?
display

; Функциите (процедурите) се прилагат в префиксна форма,
; т.е. пишем операцията най-отпред:
; (<name> <arg1> <arg2> ...)
; Извикването го ограждаме със () скоби.
; Може да си мислим за тях като списъци, които обикновено
; се оценяват последователно.

(+ 1 2)
(* 1 2 3 4)
; някои аритметични операции работят
; над произволен брой аргументи.

; По-напред в курса ще видим как можем
; да имплементираме такива.

; Има и някои некомутативни:
(- 2 5 5)  ; (2 - 5) - 5 = -8
(/ 10 2 2) ; (10 /2) / 2 = 5/2

; "=" работи само за числа и директно сравнява стойностите
(=      0.5 1/2) ;#t

; По-слoжни изрази - комбинации
(+ 2
   (/ 10 5)
   (* 1 2 3))

; Стила за идентация, който препоръчвам
; -------------------------------------
; При разбиване на извикване на функция на няколко реда:
;   - изнасям аргументите на нови редове заедно с
;     отварящата скоба, еднакво идентирани
;     (по-навътре от фунцкията).
;   - горното правило се прилага за вложени извиквания.
;   - скобите се затварят зад последния аргумент от
;     извикването.

; По конвенция:
; - функциите, връщащи булеви стойности завършват на "?"
(zero? 0)  ;#t

; Анонимни/Ламбда функции
; -----------------------
; Функции без име, които можем да конструираме на място
(lambda (x y) (expt x y))
; Обикновено извикванията на функции се оценяват
; последователно (стриктно).

; Изключенията от това правило наричаме специални форми,
; като "lambda" е точно такава.
; Няма смисъл да оценяваме тялото преди да сме получили аргументите.

; Може да конструираме следното, без да получаваме грешка:
(lambda (x) (/ x 0))

; Синтаксис за дефиниране на символи
; (придаване на стойност).
(define x 2)
; Можем да свързваме символи и с други символи.
(define add +)
(add 5 2)  ; 7
; Аргументите все още се оценяват стриктно преди да се
; присвои стойността.
; (define 2div0 (/ 2 0))  ;грешка!

; Можем да дефинираме и функции:
; (define
;   (<name> <arg1> <arg2> ..)
;   <body>)

(define (square x) (* x x))
(define (is-positive? x) (> x 0))

; В този случай тялото не се оценява стриктно,
; защото define също е специална форма.

; Това не е съвпадение. Горния синтаксис за дефиниране на
; функция е синтактична захар за свързване на символ
; с ламбда функция.

; Функциите са просто синтаксис,
; който пазим като стойност на символа.
(define i-am-a-function
  (lambda () "Call me :3"))

; Функциите, както всички останали стойности, можем да:
; - подаваме като аргумент на други функции
; - връщаме като резултат от други функции

; Функции които приемат или връщат функция,
; наричаме функции от по-висок ред.

; За функция на един аргумент f, връщаме композицията (f.f)
(define (double f)
  (lambda (x) (f (f x))))

; if е специална форма и е израз.
; Можем да го свържем със символ.
; (if <condition> <then-value> <else-value>)
; Условието е #t ако не е #f
(define one-eq-two?
  (if (= 1 2)
      "Im the pope!"
      "Expected"))

; cond е друг условен израз и също е специална форма.
; Може и без else, ако искаме празна стойност като резултат
(define (abs-val x)
  (cond ((< x 0) (- x))
        ((= x 0) 0)
        (else x)))

; булевите операции and и or са специални форми.
(define div-or? (or #t (/ 2 0)))
(define div-and? (and #f (/ 2 0)))

; Ето някои вградени функции:
; *, +, -, /
; remainder, quotient, max, min, gcd, lcm,
; floor, ceiling, round,
; exp, expt, sqrt, log,
; <, >, =, <=, >=,
; zero?, negative?, positive?, even?, odd?
; boolean?, number?, char?, string?,
; equal?

; Гледайте документацията за справка (F1 в DrRacket).

;===============;=========================================
;; З А Д А Ч И ;;
;;;;;;;;;;;;;;;;;

; NOTE: на мястото на 'undefined попълвате решението си.

; 1. За дадено естествено число n намира n+1.
(define (succ n) 'undefined)

; 2. За дадено естествено число n намира n-1.
(define (pred n) 'undefined)

; 3. За дадено число n, връща:
;     1) n/2, ако n е четно
;     2) n, в противен случай
(define (safe-div n) 'undefined)

; 4. Намира n!.
(define (factorial n) 'undefined)

; 5. Намира n-тото число на Фибоначи.
(define (fib n) 'undefined)

; 6. Намира сумата на 2 естествени числа.
; Използвайте succ и pred.
(define (sum n m) 'undefined)

; 7. намира произведението на 2 естествени числа.
; Използвайте sum/succ и pred.
(define (product n m) 'undefined)

; 8. За даден едноместен предикат p, връща отрицанието му.
; Не отрицанието на резултата,
; а нов предикат който е отрицание на p.
(define (complement p) 'undefined)

; 9. За дадена функция на два аргумента f,
; връща функцията над разменени аргументи.
(define (flip f) 'undefined)

; 10. За дадени едноаргументни функции f и g
; връща композицията им (f.g)
; Пример: ((compose f g) x) -> (f (g x))
(define (compose f g) 'undefined)

; 11. За дадена едноаргументна функция f и число n,
; връща n-тото прилагане на f. Тоест f^n.
; Пример: ((repeat f 3) x) -> (f (f (f x))) за някоя f
(define (repeat f n) 'undefined)
