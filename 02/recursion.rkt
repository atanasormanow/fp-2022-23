#lang racket

; THROWBACK:
;-----------
; - функции
; - всичко е стойност (в частност функциите)
; - define, lambda
; - рекурсия

; Вложени дефиниции:
;-------------------
; Миналия път показахме как се дефинират функции.
(define (plus2 n) (+ n 2))

; Можем да правим вложени дефиниции.
(define (square-plus2 n)
  (define (square x) (expt x 2))
  (+ (square n) 2))

(square-plus2 3) ; 11

; Има и още няколко специални форми с които можем да правим
; вложени дефиниции: let, let*, letrec

; Анонимна форма на let
(let ((x 2)
      (y 3))
  (+ x y)) ; 5

; Именована форма на let
(let fact ((n 5))
  (if (zero? n)
    1
    (* n (fact (- n 1)))))

; Можем да симулираме let чрез lambda
((lambda (x y) (+ x y)) 2 3)

; Като let, но можем да използваме предходни дефиниции
; и да предефинираме символи.
(let* ((x 1)
       (y (+ x 1)))
  (list y x))

; Като let* но във всяка дефиниция можем да ползваме
; всяка друга
(letrec ((is-even? (lambda
                     (n)
                     (or (zero? n)
                         (is-odd? (- n 1)))))
         (is-odd? (lambda
                    (n)
                    (and (not (zero? n))
                         (is-even? (- n 1))))))
  (is-odd? 11))


; Примитивна vs. опашкова рекурсия:
;----------------------------------
; Нека разгледаме n!
(define (factorial n)
  (if (= n 0)
    1
    (* n (factorial (- n 1)))))

; ако бележим "factorial"с "f",
; то изчислителния процес на (f 5) ще изглежда така:
;(f 5)
;(* 5 (f 4))
;(* 5 (* 4 (f 3)))
;(* 5 (* 4 (* 3 (f 2))))
;(* 5 (* 4 (* 3 (* 2 (f 1)))))
;(* 5 (* 4 (* 3 (* 2 (* 1 (f 0))))))
;(* 5 (* 4 (* 3 (* 2 (* 1 1)))))
;(* 5 (* 4 (* 3 (* 2 1))))
;(* 5 (* 4 (* 3 2)))
;(* 5 (* 4 6))
;(* 5 24)
;120

; памет: O(n)
; време: О(n)

; Това е същински рекурсивен процес (примитивна рекурсия)
; защото има отложените операции.

; Използвайки вложена дефиниция:
(define (factorial-iter n)

  (define (iter product i)
    ; тук ползваме допълнителния аргумент като
    ; допълнителна променлива, в която натрупваме резултата
    (if (zero? i)
      product
      ; Тук изчислението се случва в аргументите
      (iter (* i product)
            (- i 1))))

  ; Извикваме помощната функция
  (iter 1 n))

; Вече изчислителния процес изглежда така:
;(factorial-iter 5)
;(iter 1   5)
;(iter 5   4)
;(iter 20  3)
;(iter 60  2)
;(iter 120 1)
;(iter 120 0)
;120

; време: O(n)
; памет: O(1)

; Това е линеен итеративен процес заради липсата
; на отложени операции.
; (опашкова рекурсия)

; Scheme третира опашковата рекурсия като итерация.
; Ако всички рекурсивни извиквания в една функция
; са опашкови, тя генерира линеен итеративен процес.


; Тази реализация поражда дървовиден рекурсивен процес
(define (fib n)
  (if (< n 2)
    n
    (+ (fib (- n 1))
       (fib (- n 2)))))

; време: O(2^n)

; Можем ли да го направим итеративно?
; Да, с динамично програмиране.

; Ще намираме числата на фибоначи последователно
; и ще помним предходните две.
; Така няма да трябва да ги изчисляваме всеки път
; когато ни потрябват.
(define (fib-iter n)
  (define (iter n1 n2 i)
    (if (zero? i)
      n2
      (iter n2
            (+ n1 n2)
            (- i 1))))
  (iter 0 1 n))

; Нека видим разликата във времето за изпълнение:
; (time (fib 42))
; (time (fib-iter 42))

; Тогава защо изобщо бихме използвали примитивна рекурсия,
; вместо опашкова (итерация)?

;===============;=========================================
;; З А Д А Ч И ;;
;;;;;;;;;;;;;;;;;

; 1. Намира броя на цифрите на дадено естествено число n.
; Реализирайте я с примитивна рекурсия.
(define (count-digits n) 'undefined)

; 2. За дадени цяло число x и естествено число n връща x^n.
; Реализирайте я с примитивна рекурсия.
(define (pow x n) 'undefined)

; 3. За дадени числа a и b (a < b)
; намира сумата на целите числа в интервала [a,b]
; Реализирайте я с примитивна рекурсия.
(define (interval-sum a b) 'undefined)

; 4. За дадени цели числа x и n връща x^n.
; Реализирайте я с линейна рекурсия (итерация).
(define (pow-i x n) 'undefined)

; 5. Намира броя на цифрите на дадено цяло число n.
; Реализирайте я с линейна рекурсия (итерация).
(define (count-digits-i n) 'undefined)

; 6. За дадени цели числа a и b
; намира сумата на целите числа в интервала [a,b].
; Трябва да работи и за a > b.
; Реализирайте я с линейна рекурсия (итерация).
(define (interval-sum-i a b) 'undefined)

; 7. За дадено цяло число n връща число,
; чийто цифри са в обратен ред.
; Реализирайте го с линейна рекурсия (итерация).
(define (reverse-digits-i n) 'undefined)

; 8. За дадени цели числа x и n връща x^n, но
; ако n е четно, то x^n = (x^2)^(n/2))
; Реализирайте я с линейна рекурсия (итерация).
(define (fast-pow x n) 'undefined)
